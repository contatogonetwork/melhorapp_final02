√ìtimo, vou iniciar uma auditoria completa no reposit√≥rio `melhorapp_final` para implementar as melhorias descritas no seu plano ‚Äî come√ßando pela detec√ß√£o de v√≠deos locais exportados e integra√ß√£o com o app para revis√£o. Em seguida, seguiremos com coment√°rios temporais, assets compartilhados e aprova√ß√£o final.

Te aviso assim que a an√°lise e os ajustes iniciais estiverem prontos.


# Integra√ß√£o de Recursos de V√≠deo e Feedback no Projeto

## Detec√ß√£o Autom√°tica de Novos V√≠deos (Watcher Local)

Para detectar exporta√ß√µes do Adobe Premiere em uma pasta local e registrar automaticamente no app, criamos um **script Node.js** externo e uma **rota de API interna** em Next.js:

* **Watcher local (`video-watcher.js` na raiz do projeto):** Monitora recursivamente a pasta `public/exports/` por novos arquivos `.mp4`. Ao detectar um novo arquivo (evento de rename/cria√ß√£o), extrai o nome da subpasta (assumida como ID do evento/projeto) e o nome do arquivo de v√≠deo, ent√£o faz uma requisi√ß√£o `POST` para a API interna do Next (`/api/events/upload-from-watcher`) informando `eventId` (pasta) e detalhes do v√≠deo.

```js
// video-watcher.js (Executado fora do Next.js)
const fs = require('fs');
const path = require('path');
const axios = require('axios');

const EXPORTS_DIR = path.resolve(__dirname, 'public/exports');
const SERVER_API = 'http://localhost:3000/api/events/upload-from-watcher';

fs.watch(EXPORTS_DIR, { recursive: true }, async (eventType, filename) => {
  // Monitora apenas novos arquivos de v√≠deo
  if (eventType === 'rename' && filename.endsWith('.mp4')) {
    const [eventFolder, file] = filename.split(path.sep);
    const videoPath = `/exports/${eventFolder}/${file}`;  // URL relativa dentro de /public

    console.log(`üìπ Novo v√≠deo detectado: ${videoPath}`);

    try {
      // Envia os dados para a API interna do Next para registrar o v√≠deo
      await axios.post(SERVER_API, {
        eventId: eventFolder,
        filename: file,
        url: videoPath,
      });
      console.log('‚úÖ V√≠deo registrado via API:', file);
    } catch (err) {
      console.error('Erro ao chamar API interna:', err.message);
    }
  }
});
```

**Como usar:** Execute o watcher em paralelo √† aplica√ß√£o (por exemplo, `node video-watcher.js`). Certifique-se de que a pasta `public/exports/` exista e seja organizada por evento/projeto conforme necess√°rio (ex.: `public/exports/evento-001/v1.mp4`). Em ambiente de produ√ß√£o (como Vercel ou semelhante, que n√£o permite scripts residentes), esse watcher deve rodar em uma m√°quina local ou servidor separado que tenha acesso ao sistema de arquivos de exporta√ß√£o, apontando a URL da API do servidor Next.

* **API interna Next (`app/api/events/upload-from-watcher/route.ts`):** Recebe a chamada do watcher e integra o novo v√≠deo ao estado do aplicativo. Essa rota busca o projeto correspondente ao `eventId` fornecido e adiciona uma nova vers√£o de v√≠deo. Como estamos usando Zustand no cliente, aqui simplificamos registrando na estrutura de dados mantida em mem√≥ria. (Em um cen√°rio real, poder√≠amos persistir em banco de dados e usar *revalidation* ou *WebSockets* para atualizar o client).

```ts
// app/api/events/upload-from-watcher/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { useProjectsStore } from '@/store/useProjectsStore';

export async function POST(req: NextRequest) {
  const { eventId, filename, url } = await req.json();
  const store = useProjectsStore.getState();

  // Procura o projeto pelo ID (eventId)
  const project = store.projects.find(p => p.id === eventId);
  if (!project) {
    return NextResponse.json({ error: 'Projeto n√£o encontrado' }, { status: 404 });
  }

  // Identifica (ou cria) o deliverable de v√≠deo principal para adicionar a vers√£o
  const deliverable = project.videos[0] ?? { 
    id: 'main', 
    title: 'V√≠deo Principal', 
    versions: [] 
  };

  // Cria nova vers√£o de v√≠deo com dados fornecidos
  const newVersionId = Date.now().toString();
  const newVersion = {
    id: newVersionId,
    name: filename,           // usar nome do arquivo como nome da vers√£o
    url: url,                 // URL relativa para acessar em /public
    uploadedAt: new Date().toISOString(),
    active: false,
    approved: false,
    approvedBy: undefined,
    approvalNotes: undefined,
    approvedAt: undefined,
  };

  // Adiciona a vers√£o e atualiza o projeto no store
  deliverable.versions.push(newVersion);
  const updatedProject = {
    ...project,
    videos: [ deliverable ],  // garante ao menos um deliverable
  };
  store.projects = store.projects.map(p => p.id === eventId ? updatedProject : p);
  store.currentProject = updatedProject;

  return NextResponse.json({ success: true, video: newVersion });
}
```

**Configura√ß√£o:** Coloque o arquivo acima em `app/api/events/upload-from-watcher/route.ts`. O watcher local enviar√° requisi√ß√µes para essa rota. Note que estamos armazenando os v√≠deos adicionados diretamente no estado Zustand do servidor Next.js ‚Äì isso funciona apenas enquanto o servidor estiver em execu√ß√£o e *n√£o persiste dados*. Para um ambiente real, seria necess√°rio salvar em um banco de dados ou outra camada de persist√™ncia e notificar os clientes (via *subscribe* do Zustand com `persist` ou via WebSocket).

**Importante:** Ao rodar localmente em modo de desenvolvimento (`npm run dev`), a API acima funcionar√°. Se estiver usando hot-reload do Next, o estado do store no servidor pode resetar em cada altera√ß√£o de c√≥digo. Para teste consistente, considere desabilitar auto-reload ou integrar persist√™ncia. Em produ√ß√£o serverless, essa abordagem n√£o persistir√° estado entre requisi√ß√µes ‚Äì idealmente, utilize um backend persistente ou adapte para que o watcher fa√ßa requisi√ß√£o a um backend real. Aqui, serve como prova de conceito para automa√ß√£o do fluxo de trabalho.

## Coment√°rios Temporais Sincronizados com o V√≠deo

Para permitir coment√°rios atrelados a pontos espec√≠ficos do v√≠deo, implementaremos:

1. **Overlay de coment√°rios no player de v√≠deo:** exibe cart√µes sobre o v√≠deo no instante em que um coment√°rio deve aparecer.
2. **Marcadores clic√°veis na timeline:** j√° temos `CommentMarkersTimeline` e `CommentMarker` exibindo marcadores na barra de progresso do v√≠deo. Precisamos assegurar que clicar neles ou em itens de coment√°rio salta para o tempo correto no player.
3. **Adicionar coment√°rios com timestamp atual:** um bot√£o de ‚Äú+ Comentar‚Äù sobreposto ao player que, ao ser clicado, abre um campo de texto (ou utiliza o j√° existente) para adicionar um coment√°rio no instante atual do v√≠deo.
4. **Marcar coment√°rios como resolvidos/reabertos:** integrando com status visual (por exemplo, marcador verde para resolvido).

A seguir, apresentamos os componentes e ajustes necess√°rios:

* **Store de coment√°rios (Zustand):** Vamos armazenar os coment√°rios dentro do estado do projeto, associando-os a cada deliverable (v√≠deo) para evitar duplicidade de l√≥gica. Primeiro, assegure que a interface `Comment` no projeto inclua os campos necess√°rios (j√° definido em `types/project.ts`):

  ```ts
  // types/project.ts (trecho relevante)
  export interface Comment {
    id: string;
    projectId: string;
    userId: string;
    timestamp: number;   // instante no v√≠deo em segundos
    content: string;
    createdAt: string;
    resolved: boolean;
    replies?: Comment[];
  }
  ```

  Agora, no `useProjectsStore.ts`, substitua a implementa√ß√£o de `addComment` por uma vers√£o que atualiza o projeto/deliverable correto em vez de usar um array global. Tamb√©m adicionaremos um m√©todo para reabrir (marcar como n√£o resolvido) se necess√°rio. Por exemplo:

  ```ts
  // store/useProjectsStore.ts (adi√ß√£o/ajuste de m√©todos dentro do create({...}))
  addComment: (projectId, deliverableId, content, timestamp) => set((state) => {
    const projects = state.projects.map(project => {
      if (project.id !== projectId) return project;
      const updatedVideos = project.videos.map(video => {
        if (video.id !== deliverableId) return video;
        // Cria novo coment√°rio com timestamp atual
        const newComment: Comment = {
          id: crypto.randomUUID(),
          projectId,
          userId: state.currentProject?.editorId || "user", // ou obter do contexto do usu√°rio logado
          timestamp,
          content,
          createdAt: new Date().toISOString(),
          resolved: false,
        };
        const updatedComments = [...(video.comments || []), newComment];
        return { ...video, comments: updatedComments };
      });
      return { ...project, videos: updatedVideos };
    });
    return { projects, currentProject: projects.find(p => p.id === projectId) || state.currentProject };
  }),

  resolveComment: (projectId, deliverableId, commentId, resolved) => set((state) => {
    const projects = state.projects.map(project => {
      if (project.id !== projectId) return project;
      const updatedVideos = project.videos.map(video => {
        if (video.id !== deliverableId) return video;
        const updatedComments = (video.comments || []).map(comment =>
          comment.id === commentId ? { ...comment, resolved } : comment
        );
        return { ...video, comments: updatedComments };
      });
      return { ...project, videos: updatedVideos };
    });
    return { projects, currentProject: projects.find(p => p.id === projectId) || state.currentProject };
  }),
  ```

  *(Obs: Acima usamos `crypto.randomUUID()` para gerar IDs √∫nicos dos coment√°rios. Assegure-se que o ambiente suporta essa fun√ß√£o ou use outro m√©todo de gera√ß√£o de ID (ex.: uuid).)*

  Com isso, os coment√°rios s√£o armazenados dentro de `currentProject.videos[x].comments`. O m√©todo `markCommentResolved` j√° existente foi ajustado para usar `resolveComment` internamente, ou voc√™ pode mant√™-lo semelhante ao mostrado acima definindo `resolved: true/false`. Assim evitamos redund√¢ncia e utilizamos a estrutura existente de projetos.

* **Componente de Overlay de Coment√°rio:** Mostra os coment√°rios *n√£o resolvidos* cujo timestamp est√° pr√≥ximo do tempo atual do v√≠deo (por ex., dentro de 1 segundo de diferen√ßa), em forma de bal√µes sobre o player. Coloque este componente em `components/video/CommentOverlay.tsx`:

  ```tsx
  // components/video/CommentOverlay.tsx
  'use client';
  import { useProjectsStore } from '@/store/useProjectsStore';
  import { useEffect, useState } from 'react';

  interface CommentOverlayProps {
    currentTime: number;
    deliverableId: string;
  }

  export default function CommentOverlay({ currentTime, deliverableId }: CommentOverlayProps) {
    const project = useProjectsStore(s => s.currentProject);
    const [visibleComments, setVisibleComments] = useState<typeof project.videos[0].comments>([]);

    useEffect(() => {
      if (!project) return;
      // Filtra coment√°rios do deliverable atual que estejam no timestamp atual (¬±0.5s)
      const deliverable = project.videos.find(v => v.id === deliverableId);
      if (!deliverable) return;
      const activeComments = (deliverable.comments || []).filter(
        c => !c.resolved && Math.abs(c.timestamp - currentTime) < 0.5
      );
      setVisibleComments(activeComments);
    }, [currentTime, project, deliverableId]);

    if (!visibleComments.length) return null;

    return (
      <div className="absolute top-5 left-5 z-50 space-y-2">
        {visibleComments.map(comment => (
          <div key={comment.id} className="bg-black/70 text-white p-2 rounded max-w-md shadow">
            <strong>Coment√°rio</strong>: {comment.content}
          </div>
        ))}
      </div>
    );
  }
  ```

  *Detalhes:* Posicionamos os coment√°rios no canto superior esquerdo do v√≠deo (`top-5 left-5`). Cada coment√°rio aparece como um card semi-transparente. Voc√™ pode melhorar exibindo o autor (se houver campo de nome) e estilizar conforme o design do projeto. A l√≥gica utiliza uma margem de ¬±0.5s para considerar o coment√°rio "ativo" naquele instante (isso lida com pequenos desvios de atualiza√ß√£o de tempo).

* **Bot√£o de Adicionar Coment√°rio:** Um bot√£o flutuante **‚Äú+ Comentar‚Äù** no canto do player para facilitar criar um coment√°rio no momento atual. Ao clicar, pode focar o campo de texto de coment√°rio j√° existente (por exemplo, no painel lateral) ou abrir um pequeno formul√°rio. Como exemplo, adicionaremos um componente simples `AddCommentButton` em `components/video/AddCommentButton.tsx`:

  ```tsx
  // components/video/AddCommentButton.tsx
  'use client';
  interface AddCommentButtonProps {
    onClick: () => void;
  }
  export default function AddCommentButton({ onClick }: AddCommentButtonProps) {
    return (
      <button 
        onClick={onClick} 
        className="absolute top-4 right-4 bg-purple-600 text-white px-3 py-1 rounded hover:bg-purple-700 z-50"
      >
        + Comentar
      </button>
    );
  }
  ```

  Esse bot√£o deve ser posicionado dentro do container do v√≠deo (posicionado `absolute` relativo ao player). No exemplo, ele fica no canto superior direito do v√≠deo. Ao clicar, chamaremos uma fun√ß√£o `onClick` fornecida pelo pai ‚Äì por exemplo, para abrir o campo de coment√°rio. Se j√° houver um campo sempre vis√≠vel (como no `EditingWidget` original), voc√™ pode simplesmente fazer o bot√£o dar foco nesse campo ou alternar uma flag `isAdding` para destacar a caixa de coment√°rio.

* **Lista de Coment√°rios Clic√°vel:** J√° existe um componente `CommentItem` e um painel de coment√°rios no `EditingWidget`. Podemos criar um componente independente para a lista de coment√°rios caso seja √∫til em outras telas (por exemplo, em `EventDetailPage`). A lista exibe cada coment√°rio com seu timestamp e texto, e permite clicar para navegar no v√≠deo:

  ```tsx
  // components/video/CommentList.tsx
  'use client';
  import { useProjectsStore } from '@/store/useProjectsStore';
  import { format } from 'date-fns';  // para formatar timestamp se desejar
  import { ptBR } from 'date-fns/locale';

  interface CommentListProps {
    deliverableId: string;
    videoRef?: React.RefObject<HTMLVideoElement>;  // refer√™ncia ao elemento de v√≠deo para controlar playback
    onSeek?: (time: number) => void;               // fallback: fun√ß√£o para seeking caso n√£o passe videoRef
  }

  export default function CommentList({ deliverableId, videoRef, onSeek }: CommentListProps) {
    const project = useProjectsStore(s => s.currentProject);
    if (!project) return null;
    const deliverable = project.videos.find(v => v.id === deliverableId);
    if (!deliverable) return null;
    const comments = deliverable.comments || [];

    // Fun√ß√£o para ir para o tempo do coment√°rio
    const seekTo = (seconds: number) => {
      if (videoRef?.current) {
        videoRef.current.currentTime = seconds;
        videoRef.current.play();
      } else if (onSeek) {
        onSeek(seconds);
      }
    };

    return (
      <div className="space-y-2 mt-4">
        <h3 className="text-lg font-bold">Coment√°rios ({comments.length})</h3>
        {comments.map(comment => (
          <div 
            key={comment.id} 
            className={`p-2 rounded cursor-pointer ${comment.resolved ? 'bg-gray-100 text-gray-500' : 'bg-secondary text-secondary-foreground'}`}
            onClick={() => seekTo(comment.timestamp)}
          >
            <p className="text-sm text-muted-foreground">
              ‚è± {format(new Date(comment.createdAt), "Pp", { locale: ptBR })} ‚Äì <strong>{formatTime(comment.timestamp)}</strong>
            </p>
            <p>{comment.content}</p>
            {comment.resolved && <span className="text-xs text-green-600 font-medium">‚úî Resolvido</span>}
          </div>
        ))}
      </div>
    );
  }

  // Auxiliar para formatar segundos em MM:SS
  function formatTime(totalSeconds: number): string {
    const m = Math.floor(totalSeconds / 60);
    const s = Math.floor(totalSeconds % 60);
    return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
  }
  ```

  Nesse componente, usamos `videoRef` para controlar diretamente o player (caso uma refer√™ncia ao elemento `<video>` seja passada). Se o player estiver encapsulado (como em `VideoPlayer.tsx`), podemos fazer o seguinte ajuste: **permita que o `VideoPlayer` aceite uma ref externa para o `<video>` interno**. Por exemplo, no `VideoPlayerProps` adicionar `externalVideoRef?: RefObject<HTMLVideoElement>` e no JSX do v√≠deo:

  ```tsx
  <video ref={(el) => { 
            videoRef.current = el; 
            if (externalVideoRef) externalVideoRef.current = el;
          }} ... />
  ```

  Assim, do lado de fora (por exemplo, no `EditingWidget` ou em `EventDetailPage`), voc√™ pode usar `const videoElementRef = useRef<HTMLVideoElement>(null)` e passar `externalVideoRef={videoElementRef}` para o `VideoPlayer`. Ent√£o forne√ßa `videoRef={videoElementRef}` para o `CommentList`. Desse modo, o clique em um coment√°rio ajusta o tempo do v√≠deo e d√° play automaticamente. Caso n√£o seja poss√≠vel passar a ref, usamos `onSeek` como fallback: o `VideoPlayer` j√° suporta uma prop `onSeek`, ent√£o podemos cham√°-la para sincronizar (lembrando de implementar logicamente que o player busque esse tempo, por exemplo, via contexto ou estado).

* **Integra√ß√£o no Player de V√≠deo/Interface:** No componente onde voc√™ exibe o v√≠deo para revis√£o (por exemplo, dentro do tab de ‚ÄúEdi√ß√µes‚Äù ou um painel de revis√£o), envolva o player e os novos componentes em um container posicionado. Exemplo de integra√ß√£o no `EditingWidget` (ou similar, caso reestruture a UI):

  ```tsx
  // Dentro do JSX onde o v√≠deo √© exibido (e.g., EditingWidgetContent ou EventDetailPage)
  <div className="relative"> 
    {/* Container relativo para sobreposi√ß√µes */}
    <VideoPlayer 
      ref={videoPlayerRef} 
      src={...} 
      onTimeUpdate={(time, duration) => setCurrentTime(time)} 
      onSeek={(time) => setCurrentTime(time)}
      className="aspect-video"
      {/* ...ou externalVideoRef=videoElementRef se implementado */}
    />
    {/* Bot√£o de adicionar coment√°rio */}
    <AddCommentButton onClick={() => {
        setActiveTab('comments');
        // opcional: rolar para campo de texto ou focar input de coment√°rio
    }} />
    {/* Overlay de coment√°rios (passa tempo atual e ID do deliverable/v√≠deo) */}
    <CommentOverlay currentTime={currentTime} deliverableId={selectedDeliverableId} />
  </div>

  {/* Timeline de marcadores de coment√°rios */}
  <CommentMarkersTimeline 
    comments={deliverableComments} 
    duration={videoDuration} 
    onMarkerClick={(id, time) => {
      // Ao clicar no marcador, buscar o v√≠deo para o timestamp
      if (videoElementRef.current) {
        videoElementRef.current.currentTime = time;
      }
      setCurrentTime(time);
    }} 
  />

  {/* Lista de coment√°rios */}
  <CommentList deliverableId={selectedDeliverableId} videoRef={videoElementRef} />
  ```

  Acima, `deliverableComments` seria obtido do projeto atual (por exemplo, `currentProject.videos.find(v => v.id === selectedDeliverableId)?.comments || []`) e `videoDuration` pode vir do estado ou do pr√≥prio player (via onTimeUpdate guardando o duration). A lista de coment√°rios √© renderizada no painel lateral ou abaixo do v√≠deo, de acordo com o design (no `EditingWidget`, √© em uma coluna separada).

  **Obs:** Se voc√™ j√° possui parte dessa funcionalidade (por exemplo, `EditingWidget` possu√≠a l√≥gica de coment√°rios, marcadores, etc.), adapte para usar o store global em vez de estado local sempre que poss√≠vel. Remova duplica√ß√µes ‚Äì por exemplo, o `INITIAL_COMMENTS` e manipula√ß√£o local podem ser substitu√≠dos por chamadas ao `useProjectsStore`. Assim, evitamos reimplementa√ß√£o redundante. Aproveite tamb√©m a infraestrutura de colabora√ß√£o j√° presente (`useCollaboration`) para sincronizar coment√°rios em tempo real, caso aplic√°vel, apenas ajustando para usar os m√©todos do store (como `addComment`) em vez de estado local.

## Upload e Visualiza√ß√£o de Assets Compartilhados

Para gerenciar **assets compartilhados** (imagens, √°udios, logos, PDFs etc.) relacionados ao projeto, implementaremos um m√≥dulo de Assets com upload e visualiza√ß√£o:

1. **Estrutura de pastas sugerida:** Coloque os arquivos enviados em `public/assets/[eventId]/...` separados por tipo se desejar (ex.: subpastas `logos/`, `musicas/`, `imagens/`). Assim, eles ficam acess√≠veis via URL p√∫blica (Next serve qualquer coisa em `public/` diretamente).

2. **Estado global de Assets (Zustand):** O `useProjectsStore` j√° define um array global `assets: Asset[]` e m√©todos (`addAsset`, `updateAsset`, `deleteAsset`). Vamos usar isso para armazenar os assets carregados. Certifique-se de que a interface `Asset` (`types/project.ts`) cont√©m campos suficientes, por exemplo:

   ```ts
   export interface Asset {
     id: string;
     projectId: string;
     name: string;
     type: 'image' | 'video' | 'audio' | 'document';
     url: string;
     thumbnailUrl?: string;
     createdAt: string;
     uploadedBy: string;
   }
   ```

   A fun√ß√£o `addAsset` j√° existe no store; podemos melhor√°-la para definir automaticamente o tipo com base no nome ou MIME e gerar uma URL local se o arquivo for carregado via input. Exemplo de implementa√ß√£o:

   ```ts
   addAsset: (file) => set((state) => {
     if (!state.currentProject) return state;
     const projectId = state.currentProject.id;
     const id = crypto.randomUUID();
     // Determina tipo pelo tipo MIME ou extens√£o
     let type: Asset['type'];
     if (file.type.startsWith('image/')) type = 'image';
     else if (file.type.startsWith('audio/')) type = 'audio';
     else if (file.type.startsWith('video/')) type = 'video';
     else type = 'document';
     // Gera URL local tempor√°ria (nota: em produ√ß√£o, deve fazer upload real)
     const url = URL.createObjectURL(file);
     const newAsset: Asset = {
       id,
       projectId,
       name: file.name,
       type,
       url,
       createdAt: new Date().toISOString(),
       uploadedBy: 'Voc√™',
     };
     return { assets: [...state.assets, newAsset] };
   }),
   ```

   *(No caso de integra√ß√£o real, voc√™ faria upload para um servidor ou salvaria em `public/assets/...` via API, similar ao fluxo de v√≠deos. Aqui usamos `URL.createObjectURL` para pr√©-visualiza√ß√£o r√°pida.)*

3. **Componente de Upload/Lista de Assets:** Crie um componente React para o painel de assets, por exemplo `components/widgets/AssetsPanel.tsx`, que permite adicionar e listar arquivos:

   ```tsx
   // components/widgets/AssetsPanel.tsx
   'use client';
   import { useRef } from 'react';
   import { useProjectsStore } from '@/store/useProjectsStore';

   export default function AssetsPanel() {
     const inputRef = useRef<HTMLInputElement>(null);
     const assets = useProjectsStore(s => 
       // filtra assets do projeto atual
       s.assets.filter(a => a.projectId === s.currentProject?.id)
     );
     const addAsset = useProjectsStore(s => s.addAsset);

     const handleSelectFile = () => {
       inputRef.current?.click();
     };
     const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
       const file = e.target.files?.[0];
       if (file) {
         addAsset(file);
         e.target.value = ''; // reseta input
       }
     };

     return (
       <div className="p-4 space-y-4">
         <div className="flex justify-between items-center">
           <h2 className="text-xl font-bold">Assets do Projeto</h2>
           <button onClick={handleSelectFile} className="btn btn-outline flex items-center">
             üì§ Upload Asset
           </button>
         </div>
         <input 
           ref={inputRef} 
           type="file" 
           accept="image/*,video/*,audio/*,.pdf,.doc,.ppt,.xlsx" 
           className="hidden" 
           onChange={handleFileChange} 
         />

         {/* Lista de assets */}
         <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
           {assets.map(asset => (
             <div key={asset.id} className="border rounded-md p-3 bg-muted">
               <p className="text-sm font-medium mb-2">{asset.name}</p>
               {asset.type === 'image' ? (
                 <img src={asset.url} alt={asset.name} className="w-full h-auto rounded" />
               ) : asset.type === 'audio' ? (
                 <audio controls src={asset.url} className="w-full" />
               ) : asset.type === 'video' ? (
                 <video controls src={asset.url} className="w-full rounded" />
               ) : (
                 <a href={asset.url} target="_blank" rel="noopener" className="text-blue-500 underline">
                   Baixar Documento
                 </a>
               )}
             </div>
           ))}
           {assets.length === 0 && <p className="text-sm text-muted-foreground">Nenhum asset enviado ainda.</p>}
         </div>
       </div>
     );
   }
   ```

   Esse painel mostra um bot√£o **Upload Asset** (estilizado conforme seus componentes UI ‚Äì aqui usei classe gen√©rica `btn btn-outline`). Ao clicar, dispara o input de arquivo (invis√≠vel). No upload, o arquivo √© adicionado via `addAsset` no store. Em seguida, renderiza uma grade com cada asset: imagens aparecem com preview, v√≠deos e √°udios embutidos com controles, e outros tipos (pdf, documentos) aparecem como link para download/abertura em nova aba.

   **Integra√ß√£o:** Voc√™ pode incluir o `<AssetsPanel />` em uma aba espec√≠fica do projeto (por exemplo, na p√°gina de detalhes do evento, poderia haver uma aba "Assets" ou integrar no workflow). Caso j√° exista um `AssetsWidget.tsx` no projeto com interface diferente (listagem de pastas, etc.), considere combinar as funcionalidades: por exemplo, usar o mesmo estado global mas apresentar numa UI de pastas/arquivos. O importante √© evitar duplicar l√≥gica ‚Äì se o `AssetsWidget` antigo era mock, podemos substitu√≠-lo por este painel conectado ao store global.

   *Dica:* Em ambiente de produ√ß√£o, para realmente salvar os arquivos enviados, seria necess√°rio criar uma rota API para receber o upload e salvar no `public/assets/[projectId]` ou em um servi√ßo de armazenamento, ent√£o retornar a URL. Aqui simplificamos usando `URL.createObjectURL` para demonstrar a visualiza√ß√£o imediata no front-end.

## Aprova√ß√£o de Vers√µes com Hist√≥rico, Assinatura e Observa√ß√µes

Para gerenciar o fluxo de aprova√ß√£o de vers√µes de v√≠deo, implementaremos funcionalidades para marcar uma vers√£o como "ativa" e "aprovada", registrando quem aprovou e qualquer observa√ß√£o:

1. **Extens√£o da Interface de Vers√£o:** Acrescente campos de controle de aprova√ß√£o em `VideoVersion` (`types/project.ts`):

   ```ts
   export interface VideoVersion {
     id: string;
     name: string;
     url: string;
     thumbnailUrl?: string;
     uploadedAt: Date | string;
     active?: boolean;        // indica se esta vers√£o √© a atual/ativa
     approved?: boolean;      // indica se foi aprovada pelo cliente
     approvedBy?: string;     // nome/ID de quem aprovou
     approvalNotes?: string;  // observa√ß√µes da aprova√ß√£o
     approvedAt?: string;     // data/hora da aprova√ß√£o
   }
   ```

   *(Use `string` para datas se estiver serializando JSON, ou `Date` se for manipulado internamente ‚Äì coerente com o restante do projeto.)*

2. **Novos M√©todos no Store de Projetos:** No `useProjectsStore`, adicione m√©todos para marcar a vers√£o ativa e para aprovar uma vers√£o:

   ```ts
   interface ProjectsStore extends ProjectsState {
     // ... outros m√©todos
     setActiveVideoVersion: (projectId: string, deliverableId: string, versionId: string) => void;
     approveVideoVersion: (projectId: string, deliverableId: string, versionId: string, approverName?: string, notes?: string) => void;
   }
   ```

   Implementa√ß√µes:

   ```ts
   setActiveVideoVersion: (projectId, deliverableId, versionId) => set((state) => {
     const projects = state.projects.map(project => {
       if (project.id !== projectId) return project;
       const updatedVideos = project.videos.map(video => {
         if (video.id !== deliverableId) return video;
         return {
           ...video,
           versions: video.versions.map(ver => ({
             ...ver,
             active: ver.id === versionId  // apenas a vers√£o selecionada fica ativa
           }))
         };
       });
       return { ...project, videos: updatedVideos };
     });
     return { projects, currentProject: projects.find(p => p.id === projectId) || state.currentProject };
   }),

   approveVideoVersion: (projectId, deliverableId, versionId, approverName, notes) => set((state) => {
     const projects = state.projects.map(project => {
       if (project.id !== projectId) return project;
       const updatedVideos = project.videos.map(video => {
         if (video.id !== deliverableId) return video;
         return {
           ...video,
           versions: video.versions.map(ver => {
             if (ver.id !== versionId) return ver;
             return {
               ...ver,
               approved: true,
               approvedBy: approverName || 'Cliente',
               approvalNotes: notes || '',
               approvedAt: new Date().toISOString()
             };
           })
         };
       });
       return { ...project, videos: updatedVideos };
     });
     return { projects, currentProject: projects.find(p => p.id === projectId) || state.currentProject };
   }),
   ```

   Aqui, `setActiveVideoVersion` percorre os v√≠deos do projeto e marca `active=true` apenas na vers√£o escolhida (as outras ficam `active=false`). O `approveVideoVersion` marca a vers√£o como aprovada e anota quem aprovou e quando. O campo `approverName` pode ser passado como o nome do usu√°rio logado (por exemplo, o cliente que aprovou) ‚Äì se n√£o informado, usamos 'Cliente' como default. `notes` pode ser preenchido a partir de um input de observa√ß√µes.

3. **Interface de Aprova√ß√£o no Front-end:** No componente que lista as vers√µes (por exemplo, no **tab "Vers√µes de V√≠deo"** em `EventDetailPage` ou um componente dedicado), adicione bot√µes para marcar ativo e aprovar. Podemos criar ou reutilizar um componente de lista de vers√µes. Tomando como base a sugest√£o anterior `VideoList`:

   ```tsx
   // components/widgets/VideoList.tsx
   'use client';
   import { useProjectsStore } from '@/store/useProjectsStore';
   import { useState } from 'react';

   export default function VideoList({ deliverableId }: { deliverableId: string }) {
     const project = useProjectsStore(s => s.currentProject);
     const setActive = useProjectsStore(s => s.setActiveVideoVersion);
     const approve = useProjectsStore(s => s.approveVideoVersion);
     const [approvalNote, setApprovalNote] = useState<string>('');

     if (!project) return <p>Carregando...</p>;
     const deliverable = project.videos.find(v => v.id === deliverableId);
     if (!deliverable) return <p>Nenhum v√≠deo encontrado.</p>;
     const versions = deliverable.versions;

     return (
       <div className="space-y-4">
         {versions.map(v => (
           <div key={v.id} className="border p-4 rounded-md relative 
               ${v.approved ? 'border-green-600' : v.active ? 'border-yellow-500' : 'border-muted'}">
             <div className="flex justify-between items-center mb-2">
               <h4 className="font-medium">
                 {v.name} {v.active && !v.approved && <small className="text-yellow-600">(Ativa)</small>}
                 {v.approved && <small className="text-green-600">(Aprovada)</small>}
               </h4>
               <span className="text-xs text-muted-foreground">
                 {typeof v.uploadedAt === 'string' 
                   ? new Date(v.uploadedAt).toLocaleDateString('pt-BR') 
                   : v.uploadedAt.toLocaleDateString('pt-BR')}
               </span>
             </div>
             {/* Player ou thumbnail da vers√£o */}
             <video controls src={v.url} className="w-full rounded mb-2" />

             {/* Se vers√£o aprovada, mostrar detalhes */}
             {v.approved && (
               <div className="text-sm bg-green-50 text-green-900 p-2 rounded mb-2">
                 ‚úÖ Aprovado por <strong>{v.approvedBy || "Cliente"}</strong> em {v.approvedAt ? new Date(v.approvedAt).toLocaleDateString('pt-BR') : "‚Äï"}.
                 {v.approvalNotes && <p className="italic">Observa√ß√£o: "{v.approvalNotes}"</p>}
               </div>
             )}

             {/* Bot√µes de a√ß√£o */}
             {!v.approved && (
               <div className="flex items-center gap-2">
                 {!v.active && (
                   <button 
                     onClick={() => setActive(project.id, deliverableId, v.id)} 
                     className="px-3 py-1 rounded bg-yellow-600 hover:bg-yellow-700 text-white text-sm"
                   >
                     Tornar Ativa
                   </button>
                 )}
                 <button 
                   onClick={() => {
                     // Pede observa√ß√£o (se necess√°rio)
                     const note = approvalNote || window.prompt("Observa√ß√µes da aprova√ß√£o (opcional):") || "";
                     approve(project.id, deliverableId, v.id, /*approverName*/ "Voc√™", note);
                     setApprovalNote('');
                   }} 
                   className="px-3 py-1 rounded bg-green-600 hover:bg-green-700 text-white text-sm"
                 >
                   Aprovar Vers√£o
                 </button>
                 {/* Campo opcional para nota antes de aprovar */}
                 <input 
                   type="text" 
                   placeholder="Observa√ß√µes..." 
                   value={approvalNote} 
                   onChange={e => setApprovalNote(e.target.value)} 
                   className="text-sm px-2 py-1 border rounded"
                 />
               </div>
             )}
           </div>
         ))}
       </div>
     );
   }
   ```

   Neste c√≥digo, listamos todas as vers√µes do deliverable selecionado. Para cada vers√£o:

   * Mostramos seu nome e status (ativa/aprovada).
   * Exibimos um `<video>` control√°vel (pode ser um thumbnail ou frame se n√£o quisermos carregamento pesado de todos os v√≠deos; uma alternativa √© usar `<img src={version.thumbnailUrl} />` se dispon√≠vel).
   * Se a vers√£o estiver aprovada, mostramos um destaque verde com quem aprovou, quando e a observa√ß√£o (caso tenha).
   * Se n√£o estiver aprovada, exibimos bot√µes:

     * **Tornar Ativa:** dispon√≠vel se n√£o √© a vers√£o ativa atual. Chama `setActiveVideoVersion` no store.
     * **Aprovar Vers√£o:** chama `approveVideoVersion`. Aqui inclu√≠mos um fluxo para opcionalmente coletar observa√ß√µes: o componente possui um state `approvalNote` ligado a um input de texto. O usu√°rio pode digitar algo ali antes de clicar em Aprovar, ou se deixar vazio, abrimos um `window.prompt` simples para √∫ltima chance de adicionar nota (opcional). Ao aprovar, passamos `"Voc√™"` como nome de quem aprovou (substitua isso integrando com o sistema de autentica√ß√£o/usu√°rio real, e.g., nome do usu√°rio atual) e a nota coletada.
   * O estilo visual indica bordas diferentes: aprovado (verde), ativo mas n√£o aprovado (amarelo), outros (default ou muteds).

   **Onde integrar:** Este componente `VideoList` pode ser colocado na aba "Vers√µes de V√≠deo" (`TabsContent value="versions"`) em `EventDetailPage`. Por exemplo:

   ```tsx
   {selectedDeliverableId && <VideoList deliverableId={selectedDeliverableId} />}
   ```

   Isso substituiria a listagem est√°tica de vers√µes. Assim, quando o watcher adicionar uma nova vers√£o (ou um upload manual via input acontecer), a lista ser√° reativa via Zustand. Ao clicar em *Aprovar Vers√£o*, a interface atualizar√° mostrando que foi aprovada, e voc√™ pode ent√£o comunicar ao time que aquela vers√£o est√° finalizada.

   *Dica:* A "assinatura" aqui pode ser interpretada como o nome de quem aprovou. Se for necess√°rio um **documento de aprova√ß√£o assinado**, isso pode ser outro processo (por exemplo, gerar um PDF de aceite). Mas pelo enunciado, entendemos que basta registrar quem aprovou e armazenar observa√ß√µes. Isso j√° garante um hist√≥rico simples: m√∫ltiplas vers√µes ter√£o ou n√£o flag de aprova√ß√£o e quem as aprovou. Se precisar de um log completo de hist√≥rico, poderia adicionar um array `approvalHistory` dentro de `VideoDeliverable` ou `Project` registrando cada a√ß√£o de aprova√ß√£o com timestamp e usu√°rio ‚Äì por√©m, para escopo atual, a estrutura acima √© suficiente para ver qual vers√£o foi aprovada e quando.

---

**Resumo:** Com essas implementa√ß√µes, seu projeto `melhorapp_final` ganha:

* **Watcher de v√≠deo local** integrando automaticamente arquivos exportados para dentro do app, agilizando o fluxo do editor de v√≠deo.
* **Coment√°rios temporais sincronizados**, com marcadores clic√°veis e sobreposi√ß√£o no player, facilitando feedback quadro-a-quadro.
* **Gerenciamento de assets compartilhados**, permitindo equipe e cliente compartilharem refer√™ncias visuais/√°udio diretamente no projeto.
* **Controle de vers√µes de v√≠deo com aprova√ß√£o**, indicando claramente qual corte est√° em revis√£o, qual foi aprovado, por quem e com quais observa√ß√µes, mantendo um hist√≥rico de itera√ß√µes.

Cada trecho de c√≥digo fornecido segue a arquitetura modular e tipada em TypeScript, ajustando-se aos padr√µes do projeto (Zustand global store, componentes React funcionais com hooks, uso de pasta `public` para conte√∫do est√°tico). Lembre-se de revisar onde integrar esses componentes (por exemplo, substituir componentes mock existentes pelo novo c√≥digo) para evitar duplica√ß√£o. Teste cada m√≥dulo isoladamente:

1. Rodar o watcher e verificar se novos v√≠deos aparecem na aba de vers√µes.
2. Adicionar coment√°rios durante a reprodu√ß√£o e conferir se markers e overlay funcionam.
3. Fazer upload de assets e checar a listagem.
4. Marcar vers√µes ativas/aprovadas e validar a interface de hist√≥rico.

Assim, voc√™ ter√° uma aplica√ß√£o coesa para revis√£o de v√≠deo, do upload √† aprova√ß√£o final. Boa codifica√ß√£o!
